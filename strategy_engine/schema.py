"""
Schema definitions for strategy engine.

This module defines the interfaces and data structures used throughout
the strategy engine.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import pandas as pd
from dataclasses import dataclass, fields

class StrategyInterface(ABC):
    """
    Abstract base class for trading strategies.
    
    All trading strategies must implement this interface to be used
    with the strategy engine.
    """
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Generate trading signals from market data.
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            DataFrame with signal column (-1 for short, 0 for neutral, 1 for long)
        """
        DataSchema.validate_data(data)
        pass
    
    @abstractmethod
    def get_parameters(self) -> Dict[str, Any]:
        """
        Get current strategy parameters.
        
        Returns:
            Dictionary of parameter names and values
        """
        pass
    
    @abstractmethod
    def set_parameters(self, parameters: Dict[str, Any]) -> None:
        """
        Set strategy parameters.
        
        Args:
            parameters: Dictionary of parameter names and values
        """
        if not isinstance(parameters, dict):
            raise ValueError("Invalid parameter type")
        StrategyParameters.validate_parameters(parameters)
        pass

@dataclass
class StrategyParameters:
    """Parameters for trading strategies."""
    
    lookback_period: int = None
    threshold: float = None
    position_size: float = None
    
    def __post_init__(self):
        """Validate parameters after initialization."""
        if self.lookback_period is not None:
            if not isinstance(self.lookback_period, int):
                raise ValueError("Lookback period must be an integer")
            if self.lookback_period <= 0:
                raise ValueError("Lookback period must be positive")
            
        if self.threshold is not None:
            if not isinstance(self.threshold, (int, float)):
                raise ValueError("Threshold must be a number")
            if not 0 <= self.threshold <= 1:
                raise ValueError("Threshold must be between 0 and 1")
            
        if self.position_size is not None:
            if not isinstance(self.position_size, (int, float)):
                raise ValueError("Position size must be a number")
            if self.position_size <= 0:
                raise ValueError("Position size must be positive")
            
    @classmethod
    def validate_parameters(cls, parameters: Dict[str, Any]) -> None:
        """Validate parameter dictionary."""
        # Create a partial instance for validation
        field_names = {f.name for f in fields(cls)}
        valid_params = {k: v for k, v in parameters.items() if k in field_names}
        
        try:
            cls(**valid_params)
        except (TypeError, ValueError) as e:
            raise ValueError(f"Invalid parameter value: {str(e)}")

class DataSchema:
    """
    Schema definitions for market data.
    
    This class defines the required columns and data types for market data
    used in strategy evaluation.
    """
    
    REQUIRED_COLUMNS = {
        'open': float,
        'high': float,
        'low': float,
        'close': float,
        'volume': float
    }
    
    OPTIONAL_COLUMNS = {
        'adj_close': float,
        'vwap': float,
        'returns': float,
        'volatility': float
    }
    
    @staticmethod
    def validate_data(data: pd.DataFrame) -> None:
        """
        Validate market data format.
        
        Args:
            data: DataFrame to validate
            
        Raises:
            ValueError: If data format is invalid
        """
        if not isinstance(data, pd.DataFrame):
            raise ValueError("Data must be a pandas DataFrame")
            
        required_columns = {'open', 'high', 'low', 'close', 'volume'}
        if not all(col in data.columns for col in required_columns):
            raise ValueError("Data must contain required columns")
            
        if data.empty:
            raise ValueError("Data cannot be empty")

class SignalSchema:
    """
    Schema definitions for trading signals.
    
    This class defines the required columns and data types for trading signals
    generated by strategies.
    """
    
    REQUIRED_COLUMNS = {
        'signal': int  # -1 for short, 0 for neutral, 1 for long
    }
    
    OPTIONAL_COLUMNS = {
        'strength': float,  # Signal strength/confidence
        'stop_loss': float,  # Stop loss price
        'take_profit': float  # Take profit price
    }
    
    @classmethod
    def validate_signals(cls, signals: pd.DataFrame) -> bool:
        """
        Validate trading signals against schema.
        
        Args:
            signals: DataFrame to validate
            
        Returns:
            True if signals are valid, False otherwise
        """
        # Check required columns
        missing_columns = [col for col in cls.REQUIRED_COLUMNS 
                         if col not in signals.columns]
        if missing_columns:
            raise ValueError(f"Missing required columns: {missing_columns}")
            
        # Check data types
        for col, dtype in cls.REQUIRED_COLUMNS.items():
            if not pd.api.types.is_dtype_equal(signals[col].dtype, dtype):
                raise TypeError(f"Column {col} must be of type {dtype}")
                
        # Check signal values
        invalid_signals = signals[~signals['signal'].isin([-1, 0, 1])]
        if not invalid_signals.empty:
            raise ValueError("Signals must be -1, 0, or 1")
            
        return True
